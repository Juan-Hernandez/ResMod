function GGQthresholds!(thresholds::Array{Float64,1}, threspolicy::Array{Int64,2}, 								# Outputs
							consexm::Array{Float64,2}, expvalue::Array{Float64,2}, mextremes::Array{Float64,1},	# Array inputs
							bbeta::Float64, valtol::Float64, ggamma::Int64, debtnum::Int64,						# Scalar inputs
                            valuesatm::Array{Float64,2}, feasible::Array{Int64,2},					# Temporary Array inputs 
                            )
	mnew::Float64
	cons1::Float64
	val1::Float64

	thresnum=0
	setindex!(feasible,1:length(feasible),:)
	mstar::Float64=mextremes[end]	
	

	while mstar>mextremes[1]+1e-10
		
		feasible[consexm+mstar.<0]=0
	    
	    fill(valuesatm, -Inf)
	    valuesatm[feasible.>0]= (consexm[feasible.>0]+mstar).^(1-ggamma)*(1-bbeta)+expvalue[feasible.>0]
		Base.findmax!(sub(thresholds, thresnum+1), sub(threspolicy, thresnum+1,1), valuesatm[feasible.>0])
		# Revocer linear policy index
		linpolicy=feasible[ threspolicy[thresnum+1,1] ]
		# Set threshold and policies
		thresnum=thresnum+1
		setindex!(threspolicy, divrem(linpolicy, debtnum), thresnum, : )
		setindex!(thresholds, mstar, thresnum)
		# Reduce feasible set
		valuesatm[feasible.>0]= (consexm[feasible.>0]+mextremes[1]).^(1-ggamma)*(1-bbeta)+expvalue[feasible.>0]
		feasible[ valuesatm.<valuesatm[linpolicy] ]=0
		feasible[ consexm.<consexm[linpolicy] ]=0
		# find new mstar
		cons1=consexm[linpolicy]
		val1=expvalue[linpolicy]

		mstar=mextremes[1]-1e-4
		for polind in feasible[feasible>0]
			#############
			# This line has to change to a Brent's solver for gamma not equal to 2
			mnew=-0.5*(cons1+consexm[polind])+0.5*((cons1-consexm[polind])^2+4*(cons1-consexm[polind])/(val1-expvalue[polind])*(1-bbeta))^0.5;			
			#############
			mstar<mnew && (mstar=mnew)
		end
	end
	# Revert the vectors
	thresholds[1:thresnum]=flipdim(thresholds[1:thresnum], 1)
	threspolicy[1:thresnum]=flipdim(threspolicy[1:thresnum, :], 1)
	
	return thresnum
end
